一.二分查找解决的是什么类型的问题
在有序数据中快速定位目标元素

lower_bound: 第一个不小于 value 的元素
template<class ForwardIt, class T>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value);

upper_bound: 第一个大于 value 的元素  
template<class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

binary_search: 是否存在等于 value 的元素
template<class ForwardIt, class T>
bool binary_search(ForwardIt first, ForwardIt last, const T& value);

equal_range: 返回 [lower_bound, upper_bound)
template<class ForwardIt, class T>
pair<ForwardIt, ForwardIt> equal_range(ForwardIt first, ForwardIt last, const T& value);

1）查找元素是否存在
vector<int> nums = {1,3,5,7,9};
int target = 5;
bool exists = binary_search(nums.begin(),nums.end(),target);

2）精确查找位置
int index = lower_bound(nums.begin(),nums.end(),target) - nums.begin();
//如果nums[index] == target 则找到了

3）查找边界位置
vector<int> nums = {1,2,2,2,3,4};
//查找第一个 >= 2的元素的位置
int first = lower_bound(nums.begin(),nums.end(),2) - nums.begin();
//查找第一个 > 2的元素的位置
int last = upper_bound(nums.begin(),nums.end(),2) - nums.begin();
//2出现的次数
int count = last - first;

4）寻找满足条件的最小/最大值
//求满足平方 >= 100的最小整数
int left=0,right=0;
while(left<right) //搜索区间[left,right)
{
    int mid=(right-left)/2+left;
    if(mid*mid>=100)
        right=mid;//满足条件，尝试更小的值
    else 
        left=mid+1;//不满足，需要更大的值
}